#!/usr/bin/env python3
import os
import sys
import subprocess

###############################################################################
# STEP I: Preprocessing – Generate lib/templates_lib.ml and lib/scaffolder_lib.ml
###############################################################################

def build_variable_name(root_relative_path):
    """
    Given a path relative to 'src', build a variable name of the form:
    - If inside subdirs: dir_<dir1>_dir_<dir2>_..._file_<filename>_ext_<extension>
    - If in root with normal filename.ext: file_<filename>_ext_<extension>
    - If in root with pure extension (e.g., '.env'): ext_<extension_without_dot>
    """
    parts = root_relative_path.split(os.sep)
    
    # If there's only one part (i.e., file directly in src/):
    #   e.g., "main.ml" -> "file_main_ext_ml"
    #   e.g., ".env"    -> "ext_env"
    # If more subdirectories exist, we build out "dir_xxx" sections for each directory
    # before final "file_xxx_ext_xxx".
    
    # Remove any directories from the end that are actually the file name
    # so that 'parts[-1]' is the filename, and 'parts[:-1]' are directories.
    dirs = parts[:-1]
    filename = parts[-1]
    
    # Separate the filename from extension if it exists
    if filename.startswith('.'):  # pure extension, e.g. ".env"
        # var name like: ext_env
        var_name = f"ext_{filename[1:]}" if len(filename) > 1 else "ext_"  # handle edge cases
    else:
        # Split by last dot:
        if '.' in filename:
            name, ext = filename.rsplit('.', 1)
        else:
            # File with no dots => no extension
            name, ext = filename, ""
        
        if len(dirs) == 0:
            # in root of src:
            if ext == "": 
                # no extension => "file_<filename>"
                var_name = f"file_{name}"
            else:
                var_name = f"file_{name}_ext_{ext}"
        else:
            # has directory parts
            dir_chunks = []
            for d in dirs:
                dir_chunks.append(f"dir_{d}")
            if ext == "":
                var_name = "_".join(dir_chunks + [f"file_{name}"])
            else:
                var_name = "_".join(dir_chunks + [f"file_{name}", f"ext_{ext}"])
    
    return var_name

def gather_files_from_src(src_dir):
    """
    Recursively gather all files in src_dir, ignoring 'app' (no extension) in the root.
    Returns a list of (relative_path, variable_name, file_content).
    relative_path is path relative to src_dir, used later for scaffolding.
    """
    collected = []
    for root, dirs, files in os.walk(src_dir):
        # For each file, figure out its relative path to src/
        for f in files:
            full_path = os.path.join(root, f)
            rel_path = os.path.relpath(full_path, src_dir)  # e.g., "lib/Home.ml"
            
            # Check if ignoring 'src/app' with no extension in root
            # That means if rel_path == "app" AND there's no '.' in "app"
            if rel_path == "app" and '.' not in rel_path:
                continue
            
            # Build the variable name
            var_name = build_variable_name(rel_path)
            
            # Read the file content
            with open(full_path, 'r', encoding='utf-8') as infile:
                content = infile.read()
            
            collected.append((rel_path, var_name, content))
    return collected

def write_templates_lib(all_files):
    """
    Writes lib/templates_lib.ml with let-bindings like:
    let dir_lib_file_home_ext_ml = {| <content> |}
    ...
    """
    os.makedirs("lib", exist_ok=True)
    output_path = os.path.join("lib", "templates_lib.ml")
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("(* AUTO-GENERATED by compile.py Step 0 *)\n\n")
        for _, var_name, content in all_files:
            # Escape any {| or |} inside the content? Typically not needed if we trust the input,
            # but if your files had literal {| or |}, that could conflict with the syntax.
            f.write(f"let {var_name} = {{|\n{content}\n|}}\n\n")
        print(f"[INFO] Step I - Generated {output_path}")

def write_scaffolder_lib(all_files):
    """
    Write lib/scaffolder_lib.ml, including a scaffold function that:
      1) ensures directories exist
      2) writes each file from Templates_lib
      3) specifically writes compile.sh and chmod +x it
    """
    os.makedirs("lib", exist_ok=True)
    output_path = os.path.join("lib", "scaffolder_lib.ml")
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("(* AUTO-GENERATED by compile.py Step 0 *)\n\n")

        f.write("let ensure_dir path =\n")
        f.write("  if Sys.file_exists path then\n")
        f.write("    Printf.printf \"[INFO] scaffolds - Directory '%s' already exists, skipping creation.\\n\" path\n")
        f.write("  else begin\n")
        f.write("    Unix.mkdir path 0o755;\n")
        f.write("    Printf.printf \"[INFO] scaffolds - Created directory: %s\\n\" path\n")
        f.write("  end\n\n")

        f.write("let rec ensure_full_path path =\n")
        f.write("  if not (Sys.file_exists path) then begin\n")
        f.write("    ensure_full_path (Filename.dirname path);\n")
        f.write("    Unix.mkdir path 0o755;\n")
        f.write("    Printf.printf \"[INFO] scaffolds - Created directory: %s\\n\" path\n")
        f.write("  end\n\n")

        f.write("let write_file filename content =\n")
        f.write("  let oc = open_out filename in\n")
        f.write("  output_string oc content;\n")
        f.write("  close_out oc;\n")
        f.write("  Printf.printf \"[INFO] scaffolds - Created or updated file: %s\\n\" filename\n\n")

        f.write("let scaffold target_dir =\n")
        f.write("  ensure_full_path target_dir;\n\n")
        f.write("  let full_path sub_path = Filename.concat target_dir sub_path in\n\n")

        # For each file, we create directories and write files
        for rel_path, var_name, _ in all_files:
            sub_dir = os.path.dirname(rel_path)
            if sub_dir != "":
                f.write(f"  ensure_full_path (full_path \"{sub_dir}\");\n")
            f.write(f"  write_file (full_path \"{rel_path}\") Templates_lib.{var_name};\n\n")

        # After writing everything, specifically handle compile.sh
        f.write("  (* Make compile.sh executable *)\n")
        f.write("  let compile_sh_path = full_path \"compile.sh\" in\n")
        f.write("  if Sys.file_exists compile_sh_path then (\n")
        f.write("    Unix.chmod compile_sh_path 0o755;\n")
        f.write("    Printf.printf \"[INFO] scaffolds - Set +x on compile.sh\\n\"\n")
        f.write("  );\n\n")

        f.write("  print_endline \"[INFO] scaffolds - Scaffolding complete. You can now edit your files or compile.\";\n")

    print(f"[INFO] Step I - Generated {output_path}")

def step1_preprocessing():
    print("[INFO] Step I - Preprocessing – Generating templates_lib.ml and scaffolder_lib.ml from src/ ...")
    src_dir = "src"
    if not os.path.isdir(src_dir):
        print(f"[WARNING] Step I - 'src' directory not found at {os.path.abspath(src_dir)}. Skipping generation.")
        return
    
    all_files = gather_files_from_src(src_dir)
    write_templates_lib(all_files)
    write_scaffolder_lib(all_files)
    print("[INFO] Step I - Preprocessing complete")

###############################################################################
# Steps I–IV: Compile, Link, Cleanup, and (optionally) generate test scaffold
###############################################################################
# These steps basically perform the equivalent of this shell script:
# #!/bin/bash

# # Helper message to inform the user about the flag
# echo "Use the --and_generate_test_scaffold flag to generate the test scaffold."

# # Step I - Compile modules in order of dependencies
# # Although, we can use 'ocamlc -c file_name.ml', when we specify paths in our command we need to use 'ocamlc -c -I lib lib/file_name.ml'
# ocamlc -c -I lib lib/templates_lib.ml
# ocamlc -c -I lib lib/scaffolder_lib.ml
# Include the unix directory in the search path
# ocamlc -c -I lib -I +unix lib/templates_lib.ml
# ocamlc -c -I lib -I +unix lib/scaffolder_lib.ml



# # Step II - Link modules to main in order of dependencies
# ocamlc -I lib -I +unix -o scaffolds unix.cma lib/templates_lib.cmo lib/scaffolder_lib.cmo main.ml

# # Step III - Remove all .cmo, .cmi, .out files from the pwd and all sub-directories
# find . -type f \( -name "*.cmo" -o -name "*.cmi" -o -name "*.out" \) -exec rm -f {} +

# # Step IV - Check for the --and_generate_test_scaffold flag and execute the scaffold command if present
# if [[ " $@ " =~ " --and_generate_test_scaffold " ]]; then
#   # Remove the test directory if it exists
#   if [ -d "test" ]; then
#     rm -rf test
#     echo "Existing 'test' directory removed."
#   fi
# 
#   # Execute the scaffold generation
#   ./scaffolds --scaffold test
#   echo "Test scaffold has been generated."
# fi
##############################################################################

def step2_compile():
    """
    Step II: Compile modules in order of dependencies.
    """
    print("[INFO] Step II - Compiling modules...")
    subprocess.run(["ocamlc", "-c", "-I", "lib", "-I", "+unix", "lib/templates_lib.ml"], check=True)
    subprocess.run(["ocamlc", "-c", "-I", "lib", "-I", "+unix", "lib/scaffolder_lib.ml"], check=True)

def step3_link():
    """
    Step III: Link modules to main in order of dependencies
    """
    print("[INFO] Step III - Linking modules...")
    # Updated command with -I +unix
    subprocess.run([
        "ocamlc",
        "-I", "lib",
        "-I", "+unix",
        "-o", "scaffolds",
        "unix.cma",
        "lib/templates_lib.cmo",
        "lib/scaffolder_lib.cmo",
        "main.ml"
    ], check=True)


def step4_cleanup():
    """
    Step IV: Remove all .cmo, .cmi, .out files from the current dir and subdirs
    """
    print("[INFO] Step IV - Cleaning up *.cmo, *.cmi, *.out...")
    for root, dirs, files in os.walk("."):
        for f in files:
            if f.endswith((".cmo", ".cmi", ".out")):
                os.remove(os.path.join(root, f))

def step5_optional_test_scaffold(args):
    """
    Step V: Check for the --and_generate_test_scaffold flag, if present:
        - remove 'test' dir if exists
        - run ./scaffolds --scaffold test
    """
    if "--and_generate_test_scaffold" in args:
        print("[INFO] Step V - Detected --and_generate_test_scaffold flag.")
        if os.path.isdir("test"):
            print("[INFO] Step V - Removing existing 'test' directory...")
            subprocess.run(["rm", "-rf", "test"], check=True)
        print("[INFO] Step V - Generating test scaffold via ./scaffolds --scaffold test")
        subprocess.run(["./scaffolds", "--scaffold", "test"], check=True)
        print("[INFO] All steps complete!")
    else:
        print("[INFO] All steps complete!")
        print("[INFO] Use the --and_generate_test_scaffold flag to generate the test scaffold.\n")

def main():
    
    # Step I: Preprocessing
    step1_preprocessing()
    
    # Step II
    step2_compile()
    
    # Step III
    step3_link()
    print("[INFO] Step III - Compilation complete.")
    
    # Step IV
    step4_cleanup()
    
    # Step V
    step5_optional_test_scaffold(sys.argv[1:])

    

if __name__ == "__main__":
    main()

